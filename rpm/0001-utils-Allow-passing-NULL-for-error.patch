From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Vojtech Trefny <vtrefny@redhat.com>
Date: Tue, 2 Feb 2021 14:30:08 +0100
Subject: [PATCH] utils: Allow passing NULL for error

First step towards fixing #527.
---
 src/utils/dbus.c      | 17 ++++-----
 src/utils/dev_utils.c | 12 ++++---
 src/utils/exec.c      | 80 +++++++++++++++++++++++++------------------
 src/utils/module.c    |  8 ++---
 4 files changed, 63 insertions(+), 54 deletions(-)

diff --git a/src/utils/dbus.c b/src/utils/dbus.c
index 4a209cd..b65281e 100644
--- a/src/utils/dbus.c
+++ b/src/utils/dbus.c
@@ -42,7 +42,7 @@ GQuark bd_utils_dbus_error_quark (void)
  * @bus_type: bus type (system or session), ignored if @connection is specified
  * @bus_name: name of the service to check (e.g. "com.redhat.lvmdbus1")
  * @obj_prefix: object path prefix for the service (e.g. "/com/redhat/lvmdbus1")
- * @error: (out): place to store error (if any)
+ * @error: (out) (allow-none): place to store error (if any)
  *
  * Returns: whether the service was found in the system
  */
@@ -59,7 +59,7 @@ gboolean bd_utils_dbus_service_available (GDBusConnection *connection, GBusType
     else {
         bus = g_bus_get_sync (bus_type, NULL, error);
         if (!bus) {
-            g_critical ("Failed to get system bus: %s\n", (*error)->message);
+            g_prefix_error (error, "Failed to get system bus: ");
             return FALSE;
         }
 
@@ -111,16 +111,11 @@ gboolean bd_utils_dbus_service_available (GDBusConnection *connection, GBusType
                                        "Introspect", NULL, NULL, G_DBUS_CALL_FLAGS_NONE,
                                        -1, NULL, error);
     if (!ret) {
-        if (*error) {
-            g_object_unref (bus);
-            return FALSE;
-        } else {
-            g_object_unref (bus);
-            return TRUE;
-        }
-    } else
-        g_variant_unref (ret);
+        g_object_unref (bus);
+        return FALSE;
+    }
 
+    g_variant_unref (ret);
     g_object_unref (bus);
     return TRUE;
 }
diff --git a/src/utils/dev_utils.c b/src/utils/dev_utils.c
index 8120bcd..4c96769 100644
--- a/src/utils/dev_utils.c
+++ b/src/utils/dev_utils.c
@@ -34,7 +34,7 @@ GQuark bd_utils_dev_utils_error_quark (void)
  * bd_utils_resolve_device:
  * @dev_spec: specification of the device (e.g. "/dev/sda", any symlink, or the name of a file
  *            under "/dev")
- * @error: (out): place to store error (if any)
+ * @error: (out) (allow-none): place to store error (if any)
  *
  * Returns: (transfer full): the full real path of the device (e.g. "/dev/md126"
  *                           for "/dev/md/my_raid") or %NULL in case of error
@@ -42,6 +42,7 @@ GQuark bd_utils_dev_utils_error_quark (void)
 gchar* bd_utils_resolve_device (const gchar *dev_spec, GError **error) {
     gchar *path = NULL;
     gchar *symlink = NULL;
+    GError *l_error = NULL;
 
     /* TODO: check that the resulting path is a block device? */
 
@@ -50,14 +51,15 @@ gchar* bd_utils_resolve_device (const gchar *dev_spec, GError **error) {
     else
         path = g_strdup (dev_spec);
 
-    symlink = g_file_read_link (path, error);
+    symlink = g_file_read_link (path, &l_error);
     if (!symlink) {
-        if (g_error_matches (*error, G_FILE_ERROR, G_FILE_ERROR_INVAL)) {
+        if (g_error_matches (l_error, G_FILE_ERROR, G_FILE_ERROR_INVAL)) {
             /* invalid argument -> not a symlink -> nothing to resolve */
-            g_clear_error (error);
+            g_clear_error (&l_error);
             return path;
         } else {
             /* some other error, just report it */
+            g_propagate_error (error, l_error);
             g_free (path);
             return NULL;
         }
@@ -77,7 +79,7 @@ gchar* bd_utils_resolve_device (const gchar *dev_spec, GError **error) {
  * bd_utils_get_device_symlinks:
  * @dev_spec: specification of the device (e.g. "/dev/sda", any symlink, or the name of a file
  *            under "/dev")
- * @error: (out): place to store error (if any)
+ * @error: (out) (allow-none): place to store error (if any)
  *
  * Returns: (transfer full) (array zero-terminated=1): a list of all symlinks (known to udev) for the
  *                                                     device specified with @dev_spec or %NULL in
diff --git a/src/utils/exec.c b/src/utils/exec.c
index 8faeb28..0c2f641 100644
--- a/src/utils/exec.c
+++ b/src/utils/exec.c
@@ -146,7 +146,7 @@ static void log_done (guint64 task_id, gint exit_code) {
  * bd_utils_exec_and_report_error:
  * @argv: (array zero-terminated=1): the argv array for the call
  * @extra: (allow-none) (array zero-terminated=1): extra arguments
- * @error: (out): place to store error (if any)
+ * @error: (out) (allow-none): place to store error (if any)
  *
  * Returns: whether the @argv was successfully executed (no error and exit code 0) or not
  */
@@ -161,7 +161,7 @@ gboolean bd_utils_exec_and_report_error (const gchar **argv, const BDExtraArg **
  * bd_utils_exec_and_report_error_no_progress:
  * @argv: (array zero-terminated=1): the argv array for the call
  * @extra: (allow-none) (array zero-terminated=1): extra arguments
- * @error: (out): place to store error (if any)
+ * @error: (out) (allow-none): place to store error (if any)
  *
  * Returns: whether the @argv was successfully executed (no error and exit code 0) or not
  */
@@ -176,7 +176,7 @@ gboolean bd_utils_exec_and_report_error_no_progress (const gchar **argv, const B
  * @argv: (array zero-terminated=1): the argv array for the call
  * @extra: (allow-none) (array zero-terminated=1): extra arguments
  * @status: (out): place to store the status
- * @error: (out): place to store error (if any)
+ * @error: (out) (allow-none): place to store error (if any)
  *
  * Returns: whether the @argv was successfully executed (no error and exit code 0) or not
  */
@@ -193,6 +193,7 @@ gboolean bd_utils_exec_and_report_status_error (const gchar **argv, const BDExtr
     guint i = 0;
     gchar **old_env = NULL;
     gchar **new_env = NULL;
+    GError *l_error = NULL;
 
     if (extra) {
         args_len = g_strv_length ((gchar **) argv);
@@ -241,16 +242,17 @@ gboolean bd_utils_exec_and_report_status_error (const gchar **argv, const BDExtr
     #define g_spawn_check_wait_status(x,y) (g_spawn_check_exit_status (x,y))
     #endif
 
-    if (!g_spawn_check_wait_status (exit_status, error)) {
-        if (g_error_matches (*error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED)) {
+    if (!g_spawn_check_wait_status (exit_status, &l_error)) {
+        if (g_error_matches (l_error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED)) {
             /* process was terminated abnormally (e.g. using a signal) */
             g_free (stdout_data);
             g_free (stderr_data);
+            g_propagate_error (error, l_error);
             return FALSE;
         }
 
-        *status = (*error)->code;
-        g_clear_error (error);
+        *status = l_error->code;
+        g_clear_error (&l_error);
     } else
         *status = 0;
 
@@ -390,6 +392,7 @@ static gboolean _utils_exec_and_report_progress (const gchar **argv, const BDExt
     gchar **old_env = NULL;
     gchar **new_env = NULL;
     gboolean success = TRUE;
+    GError *l_error = NULL;
 
     /* TODO: share this code between functions */
     if (extra) {
@@ -463,24 +466,27 @@ static gboolean _utils_exec_and_report_progress (const gchar **argv, const BDExt
         if (poll_status < 0) {
             if (errno == EAGAIN || errno == EINTR)
                 continue;
-            g_set_error (error, BD_UTILS_EXEC_ERROR, BD_UTILS_EXEC_ERROR_FAILED,
+            g_set_error (&l_error, BD_UTILS_EXEC_ERROR, BD_UTILS_EXEC_ERROR_FAILED,
                          "Failed to poll output FDs: %m");
-            bd_utils_report_finished (progress_id, (*error)->message);
+            bd_utils_report_finished (progress_id, l_error->message);
+            g_propagate_error (error, l_error);
             success = FALSE;
             break;
         }
 
         if (!out_done) {
-            if (! _process_fd_event (out_fd, &fds[0], stdout_buffer, stdout_data, &stdout_buffer_pos, &out_done, progress_id, &completion, prog_extract, error)) {
-                bd_utils_report_finished (progress_id, (*error)->message);
+            if (! _process_fd_event (out_fd, &fds[0], stdout_buffer, stdout_data, &stdout_buffer_pos, &out_done, progress_id, &completion, prog_extract, &l_error)) {
+                bd_utils_report_finished (progress_id, l_error->message);
+                g_propagate_error (error, l_error);
                 success = FALSE;
                 break;
             }
         }
 
         if (!err_done) {
-            if (! _process_fd_event (err_fd, &fds[1], stderr_buffer, stderr_data, &stderr_buffer_pos, &err_done, progress_id, &completion, prog_extract, error)) {
-                bd_utils_report_finished (progress_id, (*error)->message);
+            if (! _process_fd_event (err_fd, &fds[1], stderr_buffer, stderr_data, &stderr_buffer_pos, &err_done, progress_id, &completion, prog_extract, &l_error)) {
+                bd_utils_report_finished (progress_id, l_error->message);
+                g_propagate_error (error, l_error);
                 success = FALSE;
                 break;
             }
@@ -498,14 +504,16 @@ static gboolean _utils_exec_and_report_progress (const gchar **argv, const BDExt
         if (child_ret > 0) {
             if (*proc_status != 0) {
                 msg = stderr_data->len > 0 ? stderr_data->str : stdout_data->str;
-                g_set_error (error, BD_UTILS_EXEC_ERROR, BD_UTILS_EXEC_ERROR_FAILED,
+                g_set_error (&l_error, BD_UTILS_EXEC_ERROR, BD_UTILS_EXEC_ERROR_FAILED,
                              "Process reported exit code %d: %s", *proc_status, msg);
-                bd_utils_report_finished (progress_id, (*error)->message);
+                bd_utils_report_finished (progress_id, l_error->message);
+                g_propagate_error (error, l_error);
                 success = FALSE;
             } else if (WIFSIGNALED (status)) {
                 g_set_error (error, BD_UTILS_EXEC_ERROR, BD_UTILS_EXEC_ERROR_FAILED,
                              "Process killed with a signal");
-                bd_utils_report_finished (progress_id, (*error)->message);
+                bd_utils_report_finished (progress_id, l_error->message);
+                g_propagate_error (error, l_error);
                 success = FALSE;
             }
         } else if (child_ret == -1) {
@@ -513,7 +521,8 @@ static gboolean _utils_exec_and_report_progress (const gchar **argv, const BDExt
                 errno = 0;
                 g_set_error (error, BD_UTILS_EXEC_ERROR, BD_UTILS_EXEC_ERROR_FAILED,
                              "Failed to wait for the process");
-                bd_utils_report_finished (progress_id, (*error)->message);
+                bd_utils_report_finished (progress_id, l_error->message);
+                g_propagate_error (error, l_error);
                 success = FALSE;
             } else {
                 /* no such process (the child exited before we tried to wait for it) */
@@ -544,7 +553,7 @@ static gboolean _utils_exec_and_report_progress (const gchar **argv, const BDExt
  * @extra: (allow-none) (array zero-terminated=1): extra arguments
  * @prog_extract: (scope notified) (nullable): function for extracting progress information
  * @proc_status: (out): place to store the process exit status
- * @error: (out): place to store error (if any)
+ * @error: (out) (allow-none): place to store error (if any)
  *
  * Note that any NULL bytes read from standard output and standard error
  * output are treated as separators similar to newlines and @prog_extract
@@ -561,7 +570,7 @@ gboolean bd_utils_exec_and_report_progress (const gchar **argv, const BDExtraArg
  * @argv: (array zero-terminated=1): the argv array for the call
  * @extra: (allow-none) (array zero-terminated=1): extra arguments
  * @output: (out): variable to store output to
- * @error: (out): place to store error (if any)
+ * @error: (out) (allow-none): place to store error (if any)
  *
  * Note that any NULL bytes read from standard output and standard error
  * output will be discarded.
@@ -619,7 +628,7 @@ gboolean bd_utils_init_logging (BDUtilsLogFunc new_log_func, GError **error __at
  * bd_utils_version_cmp:
  * @ver_string1: first version string
  * @ver_string2: second version string
- * @error: (out): place to store error (if any)
+ * @error: (out) (allow-none): place to store error (if any)
  *
  * Returns: -1, 0 or 1 if @ver_string1 is lower, the same or higher version as
  *          @ver_string2 respectively. If an error occurs, returns -2 and @error
@@ -697,7 +706,7 @@ gint bd_utils_version_cmp (const gchar *ver_string1, const gchar *ver_string2, G
  *               info or %NULL to use "--version"
  * @version_regexp: (allow-none): regexp to extract version from the version
  *                  info or %NULL if only version is printed by "$ @util @version_arg"
- * @error: (out): place to store error (if any)
+ * @error: (out) (allow-none): place to store error (if any)
  *
  * Returns: whether the @util is available in a version >= @version or not
  *          (@error is set in such case).
@@ -710,6 +719,7 @@ gboolean bd_utils_check_util_version (const gchar *util, const gchar *version, c
     GRegex *regex = NULL;
     GMatchInfo *match_info = NULL;
     gchar *version_str = NULL;
+    GError *l_error = NULL;
 
     util_path = g_find_program_in_path (util);
     if (!util_path) {
@@ -723,16 +733,16 @@ gboolean bd_utils_check_util_version (const gchar *util, const gchar *version, c
         /* nothing more to do here */
         return TRUE;
 
-    succ = bd_utils_exec_and_capture_output (argv, NULL, &output, error);
+    succ = bd_utils_exec_and_capture_output (argv, NULL, &output, &l_error);
     if (!succ) {
         /* if we got nothing on STDOUT, try using STDERR data from error message */
-        if (g_error_matches ((*error), BD_UTILS_EXEC_ERROR, BD_UTILS_EXEC_ERROR_NOOUT)) {
-            output = g_strdup ((*error)->message);
-            g_clear_error (error);
-        } else if (g_error_matches ((*error), BD_UTILS_EXEC_ERROR, BD_UTILS_EXEC_ERROR_FAILED)) {
+        if (g_error_matches (l_error, BD_UTILS_EXEC_ERROR, BD_UTILS_EXEC_ERROR_NOOUT)) {
+            output = g_strdup (l_error->message);
+            g_clear_error (&l_error);
+        } else if (g_error_matches (l_error, BD_UTILS_EXEC_ERROR, BD_UTILS_EXEC_ERROR_FAILED)) {
             /* exit status != 0, try using the output anyway */
-            output = g_strdup ((*error)->message);
-            g_clear_error (error);
+            output = g_strdup (l_error->message);
+            g_clear_error (&l_error);
         }
     }
 
@@ -771,12 +781,14 @@ gboolean bd_utils_check_util_version (const gchar *util, const gchar *version, c
 
     g_free (output);
 
-    if (bd_utils_version_cmp (version_str, version, error) < 0) {
+    if (bd_utils_version_cmp (version_str, version, &l_error) < 0) {
         /* smaller version or error */
-        if (!(*error))
+        if (!l_error)
             g_set_error (error, BD_UTILS_EXEC_ERROR, BD_UTILS_EXEC_ERROR_UTIL_LOW_VER,
                          "Too low version of %s: %s. At least %s required.",
                          util, version_str, version);
+        else
+            g_propagate_error (error, l_error);
         g_free (version_str);
         return FALSE;
     }
@@ -789,7 +801,7 @@ gboolean bd_utils_check_util_version (const gchar *util, const gchar *version, c
  * bd_utils_init_prog_reporting:
  * @new_prog_func: (allow-none) (scope notified): progress reporting function to
  *                                                use or %NULL to reset to default
- * @error: (out): place to store error (if any)
+ * @error: (out) (allow-none): place to store error (if any)
  *
  * Returns: whether progress reporting was successfully initialized or not
  */
@@ -807,7 +819,7 @@ gboolean bd_utils_init_prog_reporting (BDUtilsProgFunc new_prog_func, GError **e
  * @new_prog_func: (allow-none) (scope notified): progress reporting function to
  *                                                use on current thread or %NULL
  *                                                to reset to default or global
- * @error: (out): place to store error (if any)
+ * @error: (out) (allow-none): place to store error (if any)
  *
  * Returns: whether progress reporting was successfully initialized or not
  */
@@ -830,7 +842,7 @@ static void thread_progress_muted (guint64 task_id __attribute__((unused)), BDUt
 
 /**
  * bd_utils_mute_prog_reporting_thread:
- * @error: (out): place to store error (if any)
+ * @error: (out) (allow-none): place to store error (if any)
  *
  * Returns: whether progress reporting for the current thread was successfully
  * muted (deinitialized even in presence of a global reporting function) or not
@@ -909,7 +921,7 @@ void bd_utils_report_finished (guint64 task_id, const gchar *msg) {
  * bd_utils_echo_str_to_file:
  * @str: string to write to @file_path
  * @file_path: path to file
- * @error: (out): place to store error (if any)
+ * @error: (out) (allow-none): place to store error (if any)
  *
  * Returns: whether the @str was successfully written to @file_path
  * or not.
diff --git a/src/utils/module.c b/src/utils/module.c
index 9750e24..2e8b57b 100644
--- a/src/utils/module.c
+++ b/src/utils/module.c
@@ -39,7 +39,7 @@ GQuark bd_utils_module_error_quark (void)
 /**
  * bd_utils_have_kernel_module:
  * @module_name: name of the kernel module to check
- * @error: (out): place to store error (if any)
+ * @error: (out) (allow-none): place to store error (if any)
  *
  * Returns: whether the @module_name was found in the system, either as a module
  * or built-in in the kernel
@@ -89,7 +89,7 @@ gboolean bd_utils_have_kernel_module (const gchar *module_name, GError **error)
  * bd_utils_load_kernel_module:
  * @module_name: name of the kernel module to load
  * @options: (allow-none): module options
- * @error: (out): place to store error (if any)
+ * @error: (out) (allow-none): place to store error (if any)
  *
  * Returns: whether the @module_name was successfully loaded or not
  */
@@ -151,7 +151,7 @@ gboolean bd_utils_load_kernel_module (const gchar *module_name, const gchar *opt
 /**
  * bd_utils_unload_kernel_module:
  * @module_name: name of the kernel module to unload
- * @error: (out): place to store error (if any)
+ * @error: (out) (allow-none): place to store error (if any)
  *
  * Returns: whether the @module_name was successfully unloaded or not
  */
@@ -227,7 +227,7 @@ G_LOCK_DEFINE_STATIC (detected_linux_ver);
 
 /**
  * bd_utils_get_linux_version:
- * @error: (out): place to store error (if any)
+ * @error: (out) (allow-none): place to store error (if any)
  *
  * Retrieves version of currently running Linux kernel. Acts also as an initializer for statically cached data.
  *
-- 
2.33.1

