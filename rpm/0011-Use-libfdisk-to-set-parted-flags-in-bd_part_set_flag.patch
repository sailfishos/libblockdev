From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Vojtech Trefny <vtrefny@redhat.com>
Date: Mon, 19 Nov 2018 16:30:25 +0100
Subject: [PATCH] Use libfdisk to set parted "flags" in bd_part_set_flag

Unfortunately most of the "flags" defined by parted are not flags
so we need to manually "translate" every flag to an actual flag,
partition ID or GUID.
---
 configure.ac            |   2 +-
 src/plugins/Makefile.am |   4 +-
 src/plugins/part.c      | 441 +++++++++++++++++++++++++++++++++-------
 tests/part_test.py      |  78 ++++++-
 4 files changed, 444 insertions(+), 81 deletions(-)

diff --git a/configure.ac b/configure.ac
index e3d0c11..be9740d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -247,7 +247,7 @@ AS_IF([test "x$with_fs" != "xno"],
               AC_SUBST([PARTED_FS_CFLAGS], [])])],
       [])
 
-AS_IF([test "x$with_fs" != "xno" -o "x$with_crypto" != "xno" -o "x$with_swap" != "xno"],
+AS_IF([test "x$with_fs" != "xno" -o "x$with_crypto" != "xno" -o "x$with_swap" != "xno" -o "x$with_part" != "xno"],
       [LIBBLOCKDEV_PKG_CHECK_MODULES([BLKID], [blkid >= 2.23.0])
       # older versions of libblkid don't support BLKID_SUBLKS_BADCSUM so let's just
       # define it as 0 (neutral value for bit combinations of flags)
diff --git a/src/plugins/Makefile.am b/src/plugins/Makefile.am
index 71e527a..4323f28 100644
--- a/src/plugins/Makefile.am
+++ b/src/plugins/Makefile.am
@@ -174,8 +174,8 @@ libbd_s390_la_SOURCES = s390.c s390.h check_deps.c check_deps.h
 endif
 
 if WITH_PART
-libbd_part_la_CFLAGS = $(GLIB_CFLAGS) $(GIO_CFLAGS) $(PARTED_CFLAGS) $(FDISK_CFLAGS) -Wall -Wextra -Werror
-libbd_part_la_LIBADD = ${builddir}/../utils/libbd_utils.la ${builddir}/libbd_part_err.la -lm $(GLIB_LIBS) $(GIO_LIBS) $(PARTED_LIBS) $(FDISK_LIBS)
+libbd_part_la_CFLAGS = $(GLIB_CFLAGS) $(GIO_CFLAGS) $(PARTED_CFLAGS) $(FDISK_CFLAGS) $(BLKID_CFLAGS) -Wall -Wextra -Werror
+libbd_part_la_LIBADD = ${builddir}/../utils/libbd_utils.la ${builddir}/libbd_part_err.la -lm $(GLIB_LIBS) $(GIO_LIBS) $(PARTED_LIBS) $(FDISK_LIBS) $(BLKID_LIBS)
 libbd_part_la_LDFLAGS = -L${srcdir}/../utils/ -version-info 2:0:0 -Wl,--no-undefined
 libbd_part_la_CPPFLAGS = -I${builddir}/../../include/
 libbd_part_la_SOURCES = part.c part.h check_deps.c check_deps.h
diff --git a/src/plugins/part.c b/src/plugins/part.c
index 1514dce..b0be3ad 100644
--- a/src/plugins/part.c
+++ b/src/plugins/part.c
@@ -32,6 +32,8 @@
 #include <part_err.h>
 #include <libfdisk.h>
 #include <locale.h>
+#include <blkid.h>
+#include <syslog.h>
 
 #include "part.h"
 
@@ -128,6 +130,49 @@ static gint log2i (guint x) {
     return ret;
 }
 
+/* Parted invented a lot of flags that are actually not flags, some of these are
+ * partition IDs (for MSDOS), some GUIDs (for GPT) and some both or something
+ * completely different. libfdisk logically doesn't support these "flags" so we
+ * need some way how to "translate" the flag to something that makes sense.
+ */
+
+/**
+ * PartFlag: (skip)
+ * @id: partition ID or 0 if not supported on MSDOS
+ * @guid: GUID or NULL if not supported on GPT
+ * @name: name of the flag
+ */
+typedef struct PartFlag {
+    const gchar *id;
+    const gchar *guid;
+    const gchar *name;
+} PartFlag;
+
+static const PartFlag part_flags[18] = {
+    {NULL, NULL, "boot"},                                         /* BD_PART_FLAG_BOOT -- managed separately (DOS_FLAG_ACTIVE) */
+    {NULL, NULL, "root"},                                         /* BD_PART_FLAG_ROOT  -- supported only on MAC */
+    {"0x82", "0657FD6D-A4AB-43C4-84E5-0933C84B4F4F", "swap"},     /* BD_PART_FLAG_SWAP */
+    {NULL, NULL, "hidden"},                                       /* BD_PART_FLAG_HIDDEN -- managed separately (part IDs according to FS) */
+    {"0xfd", "A19D880F-05FC-4D3B-A006-743F0F84911E", "raid"},     /* BD_PART_FLAG_RAID */
+    {"0x8e", "E6D6D379-F507-44C2-A23C-238F2A3DF928", "lvm"},      /* BD_PART_FLAG_LVM */
+    {NULL, NULL, "lba"},                                          /* BD_PART_FLAG_LBA -- managed separately (part IDs according to FS) */
+    {NULL, "E2A1E728-32E3-11D6-A682-7B03A0000000", "hp-service"}, /* BD_PART_FLAG_HPSERVICE */
+    {"0xf0", NULL, "palo"},                                       /* BD_PART_FLAG_CPALO */
+    {"0x41", "9E1A2D38-C612-4316-AA26-8B49521E5A8B", "prep"},     /* BD_PART_FLAG_PREP */
+    {NULL, "E3C9E316-0B5C-4DB8-817D-F92DF00215AE", "msftres"},    /* BD_PART_FLAG_MSFT_RESERVED */
+    {NULL, "21686148-6449-6E6F-744E-656564454649", "bios_grub"},  /* BD_PART_FLAG_BIOS_GRUB */
+    {NULL, "5265636F-7665-11AA-AA11-00306543ECAC", "atvrecv"},    /* BD_PART_FLAG_APPLE_TV_RECOVERY */
+    {"0x12", "DE94BBA4-06D1-4D40-A16A-BFD50179D6AC", "diag"},     /* BD_PART_FLAG_DIAG */
+    {NULL, NULL, "legacy_boot"},                                  /* BD_PART_FLAG_LEGACY_BOOT -- managed separately (GPT_FLAG_LEGACYBOOT) */
+    {NULL, "EBD0A0A2-B9E5-4433-87C0-68B6B72699C7", "msftdata"},   /* BD_PART_FLAG_MSFT_DATA */
+    {"0x84", "D3BFE2DE-3DAF-11DF-BA40-E3A556D89593", "irst"},     /* BD_PART_FLAG_IRST */
+    {"0xef", "C12A7328-F81F-11D2-BA4B-00A0C93EC93B", "esp"},      /* BD_PART_FLAG_ESP */
+};
+
+/* default part id/guid when removing existing "flag" */
+#define DEFAULT_PART_ID "0x83"
+#define DEFAULT_PART_GUID "0FC63DAF-8483-4772-8E79-3D69D8477DE4"
+
 /**
  * get_part_num: (skip)
  *
@@ -1375,28 +1420,17 @@ gboolean bd_part_resize_part (const gchar *disk, const gchar *part, guint64 size
 }
 
 
-static gboolean set_gpt_flag (const gchar *device, int part_num, BDPartFlag flag, gboolean state, GError **error) {
-    struct fdisk_context *cxt = NULL;
+static gboolean set_gpt_flag (struct fdisk_context *cxt, int part_num, BDPartFlag flag, gboolean state, GError **error) {
     struct fdisk_label *lb = NULL;
     const gchar *label_name = NULL;
     int bit_num = 0;
     guint64 gpt_flags = 0;
     gint status = 0;
 
-    /* first partition in fdisk is 0 */
-    part_num--;
-
-    cxt = get_device_context (device, error);
-    if (!cxt) {
-        /* error is already populated */
-        return FALSE;
-    }
-
     lb = fdisk_get_label (cxt, NULL);
     if (!lb) {
         g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
-                     "Failed to read partition table on device '%s'", device);
-        close_context (cxt);
+                     "Failed to read partition table.");
         return FALSE;
     }
 
@@ -1404,7 +1438,6 @@ static gboolean set_gpt_flag (const gchar *device, int part_num, BDPartFlag flag
     if (g_strcmp0 (label_name, table_type_str_fdisk[BD_PART_TABLE_GPT]) != 0) {
         g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_INVAL,
                      "Setting GPT flags is not supported on '%s' partition table", label_name);
-        close_context (cxt);
         return FALSE;
     }
 
@@ -1412,7 +1445,6 @@ static gboolean set_gpt_flag (const gchar *device, int part_num, BDPartFlag flag
     if (status < 0) {
         g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
                      "Failed to read GPT flags");
-        close_context (cxt);
         return FALSE;
     }
 
@@ -1436,16 +1468,9 @@ static gboolean set_gpt_flag (const gchar *device, int part_num, BDPartFlag flag
     if (status < 0) {
         g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
                      "Failed to set new GPT flags");
-        close_context (cxt);
         return FALSE;
     }
 
-    if (!write_label (cxt, device, error)) {
-        close_context (cxt);
-        return FALSE;
-    }
-
-    close_context (cxt);
     return TRUE;
 }
 
@@ -1577,6 +1602,237 @@ static gboolean set_part_type (struct fdisk_context *cxt, gint part_num, const g
     return TRUE;
 }
 
+#define _PART_FAT12       0x01
+#define _PART_FAT16       0x06
+#define _PART_FAT16_LBA   0x0e
+#define _PART_FAT32       0x0b
+#define _PART_FAT32_LBA   0x0c
+#define _PART_NTFS        0x07
+#define _PART_FLAG_HIDDEN 0x10
+
+static gint synced_close (gint fd) {
+    gint ret = 0;
+    ret = fsync (fd);
+    if (close (fd) != 0)
+        ret = 1;
+    return ret;
+}
+
+static gchar* get_lba_hidden_id (const gchar *part, gboolean hidden, gboolean lba, gboolean state, GError **error) {
+    blkid_probe probe = NULL;
+    gint fd = 0;
+    gint status = 0;
+    const gchar *value = NULL;
+    g_autofree gchar *fstype = NULL;
+    g_autofree gchar *fsversion = NULL;
+    guint partid = 0;
+    gchar *message = NULL;
+    guint ret = 0;
+    guint n_try = 0;
+
+    probe = blkid_new_probe ();
+    if (!probe) {
+        g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
+                     "Failed to create a new probe");
+        return NULL;
+    }
+
+    /* we may need to try mutliple times with some delays in case the device is
+       busy at the very moment */
+    for (n_try=5, fd=-1; (fd < 0) && (n_try > 0); n_try--) {
+        fd = open (part, O_RDONLY|O_CLOEXEC);
+        if (fd == -1)
+            g_usleep (100 * 1000); /* microseconds */
+    }
+    if (fd == -1) {
+        g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
+                     "Failed to open the device '%s'", part);
+        blkid_free_probe (probe);
+        return NULL;
+    }
+
+    /* we may need to try mutliple times with some delays in case the device is
+       busy at the very moment */
+    for (n_try=5, status=-1; (status != 0) && (n_try > 0); n_try--) {
+        status = blkid_probe_set_device (probe, fd, 0, 0);
+        if (status != 0)
+            g_usleep (100 * 1000); /* microseconds */
+    }
+    if (status != 0) {
+        g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
+                     "Failed to create a probe for the device '%s'", part);
+        blkid_free_probe (probe);
+        synced_close (fd);
+        return NULL;
+    }
+
+    blkid_probe_enable_superblocks (probe, 1);
+    blkid_probe_set_superblocks_flags (probe, BLKID_SUBLKS_USAGE | BLKID_SUBLKS_TYPE | BLKID_SUBLKS_VERSION);
+    blkid_probe_enable_partitions (probe, 1);
+    blkid_probe_set_partitions_flags (probe, BLKID_PARTS_ENTRY_DETAILS);
+
+    /* we may need to try mutliple times with some delays in case the device is
+       busy at the very moment */
+    for (n_try=5, status=-1; !(status == 0 || status == 1) && (n_try > 0); n_try--) {
+        status = blkid_do_safeprobe (probe);
+        if (status < 0)
+            g_usleep (100 * 1000); /* microseconds */
+    }
+    if (status < 0) {
+        /* -1 or -2 = error during probing*/
+        g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
+                     "Failed to probe the device '%s'", part);
+        blkid_free_probe (probe);
+        synced_close (fd);
+        return NULL;
+    } else if (status == 1) {
+        /* 1 = nothing detected */
+        blkid_free_probe (probe);
+        synced_close (fd);
+        return NULL;
+    }
+
+    if (!blkid_probe_has_value (probe, "USAGE")) {
+        blkid_free_probe (probe);
+        synced_close (fd);
+        return NULL;
+    }
+
+    status = blkid_probe_lookup_value (probe, "USAGE", &value, NULL);
+    if (status != 0) {
+        g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
+                     "Failed to get usage for the device '%s'", part);
+        blkid_free_probe (probe);
+        synced_close (fd);
+        return NULL;
+    }
+
+    if (strncmp (value, "filesystem", 10) != 0) {
+        blkid_free_probe (probe);
+        synced_close (fd);
+        return NULL;
+    }
+
+    status = blkid_probe_lookup_value (probe, "TYPE", &value, NULL);
+    if (status != 0) {
+        g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
+                     "Failed to get filesystem type for the device '%s'", part);
+        blkid_free_probe (probe);
+        synced_close (fd);
+        return NULL;
+    }
+
+    fstype = g_strdup (value);
+
+    status = blkid_probe_lookup_value (probe, "VERSION", &value, NULL);
+    if (status != 0) {
+        g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
+                     "Failed to get filesystem version for the device '%s'", part);
+        blkid_free_probe (probe);
+        synced_close (fd);
+        return NULL;
+    }
+
+    fsversion = g_strdup (value);
+
+    status = blkid_probe_lookup_value (probe, "PART_ENTRY_TYPE", &value, NULL);
+    if (status != 0) {
+        g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
+                     "Failed to get partition type for the device '%s'", part);
+        blkid_free_probe (probe);
+        synced_close (fd);
+        return NULL;
+    }
+
+    partid = g_ascii_strtoull (value, NULL, 16);
+
+    blkid_free_probe (probe);
+    synced_close (fd);
+
+    /* hidden and lba "flags" are actually partition IDs that depend on both
+     * filesystem type and version so we need to pick the right value based
+     * on the FS type and version and add LBA and/or hidden "flag" to it
+     */
+    if (g_strcmp0 (fstype, "vfat") == 0) {
+        if (g_strcmp0 (fsversion, "FAT12") == 0) {
+            ret = _PART_FAT12;
+        } else if (g_strcmp0 (fsversion, "FAT16") == 0) {
+            if ((lba && state) || (!lba && (partid & _PART_FAT16_LBA)))
+              ret = _PART_FAT16_LBA;
+            else
+              ret = _PART_FAT16;
+        } else if (g_strcmp0 (fsversion, "FAT32") == 0) {
+            if ((lba && state) || (!lba && (partid & _PART_FAT32_LBA)))
+              ret = _PART_FAT32_LBA;
+            else
+              ret = _PART_FAT32;
+        }
+    } else if (g_strcmp0 (fstype, "ntfs") == 0 || g_strcmp0 (fstype, "hpfs") == 0 || g_strcmp0 (fstype, "exfat") == 0) {
+        ret = _PART_NTFS;
+    } else {
+        /* hidden and lba flags are supported only with (v)fat, ntfs or hpfs
+         * libparted just ignores the request without returning error, so we
+         * need to do the same
+         */
+        message = g_strdup_printf ("Ignoring requested flag: setting hidden/lba flag is supported only "\
+                                   "on partitions with FAT, NTFS or HPFS filesystem.");
+        bd_utils_log (LOG_INFO, message);
+        g_free (message);
+        return NULL;
+    }
+
+    /* "add" the hidden flag if requested or if it was set before and unsetting
+     * was not requested */
+    if ((hidden && state) || (!hidden && (partid & _PART_FLAG_HIDDEN)))
+        ret |= _PART_FLAG_HIDDEN;
+
+    /* both lba and hidden were removed -> set default ID */
+    if (ret == _PART_NTFS || ret == _PART_FAT12 || ret == _PART_FAT16 || ret == _PART_FAT32)
+        return g_strdup (DEFAULT_PART_ID);
+
+    return g_strdup_printf ("0x%.2x", ret);
+}
+
+
+static gboolean set_boot_flag (struct fdisk_context *cxt, guint part_num, gboolean state, GError **error) {
+    struct fdisk_partition *pa = NULL;
+    gint ret = 0;
+
+    ret = fdisk_get_partition (cxt, part_num, &pa);
+    if (ret != 0) {
+        g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
+                     "Failed to get partition '%d'.", part_num);
+        return FALSE;
+    }
+
+    ret = fdisk_partition_is_bootable (pa);
+    if ((ret == 1 && state) || (ret != 1 && !state)) {
+        /* boot flag is already set as desired, no change needed */
+        fdisk_unref_partition (pa);
+        return TRUE;
+    }
+
+    ret = fdisk_toggle_partition_flag (cxt, part_num, DOS_FLAG_ACTIVE);
+    if (ret != 0) {
+        g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
+                     "%s", strerror_l (-ret, c_locale));
+        fdisk_unref_partition (pa);
+        return FALSE;
+    }
+
+    ret = fdisk_write_disklabel (cxt);
+    if (ret != 0) {
+        g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
+                     "Failed to write changes to the disk: %s", strerror_l (-ret, c_locale));
+        fdisk_unref_partition (pa);
+        return FALSE;
+    }
+
+    fdisk_unref_partition (pa);
+
+    return TRUE;
+}
+
 /**
  * bd_part_set_part_flag:
  * @disk: disk the partition belongs to
@@ -1591,84 +1847,129 @@ static gboolean set_part_type (struct fdisk_context *cxt, gint part_num, const g
  * Tech category: %BD_PART_TECH_MODE_MODIFY_PART + the tech according to the partition table type
  */
 gboolean bd_part_set_part_flag (const gchar *disk, const gchar *part, BDPartFlag flag, gboolean state, GError **error) {
-    PedDevice *dev = NULL;
-    PedDisk *ped_disk = NULL;
-    PedPartition *ped_part = NULL;
-    PedPartitionFlag ped_flag = PED_PARTITION_FIRST_FLAG;
+    struct fdisk_context *cxt = NULL;
+    struct fdisk_label *lb = NULL;
+    const gchar *label_name = NULL;
     gint part_num = 0;
-    gint status = 0;
-    gboolean ret = FALSE;
     guint64 progress_id = 0;
     gchar *msg = NULL;
+    PartFlag flag_info;
+    gchar *part_id = NULL;
 
     msg = g_strdup_printf ("Started setting flag on the partition '%s'", part);
     progress_id = bd_utils_report_started (msg);
     g_free (msg);
 
-    dev = ped_device_get (disk);
-    if (!dev) {
-        set_parted_error (error, BD_PART_ERROR_INVAL);
-        g_prefix_error (error, "Device '%s' invalid or not existing", disk);
+    part_num = get_part_num (part, error);
+    if (part_num == -1) {
         bd_utils_report_finished (progress_id, (*error)->message);
         return FALSE;
     }
 
-    ped_disk = ped_disk_new (dev);
-    if (!ped_disk) {
-        set_parted_error (error, BD_PART_ERROR_FAIL);
-        g_prefix_error (error, "Failed to read partition table on device '%s'", disk);
-        ped_device_destroy (dev);
+    /* first partition in fdisk is 0 */
+    part_num--;
+
+    cxt = get_device_context (disk, error);
+    if (!cxt) {
+        /* error is already populated */
         bd_utils_report_finished (progress_id, (*error)->message);
         return FALSE;
     }
 
-    part_num = get_part_num (part, error);
-    if (part_num == -1) {
-        ped_disk_destroy (ped_disk);
-        ped_device_destroy (dev);
-        bd_utils_report_finished (progress_id, (*error)->message);
-        return FALSE;
+    /* GPT flags */
+    if (flag > BD_PART_FLAG_BASIC_LAST || flag == BD_PART_FLAG_LEGACY_BOOT) {
+        if (!set_gpt_flag (cxt, part_num, flag, state, error)) {
+            bd_utils_report_finished (progress_id, (*error)->message);
+            close_context (cxt);
+            return FALSE;
+        }
+
+        if (!write_label (cxt, disk, error)) {
+            bd_utils_report_finished (progress_id, (*error)->message);
+            close_context (cxt);
+            return FALSE;
+        }
+
+        bd_utils_report_finished (progress_id, "Completed");
+        close_context (cxt);
+        return TRUE;
     }
 
-    ped_part = ped_disk_get_partition (ped_disk, part_num);
-    if (!ped_part) {
-        set_parted_error (error, BD_PART_ERROR_FAIL);
-        g_prefix_error (error, "Failed to get partition '%d' on device '%s'", part_num, disk);
-        ped_disk_destroy (ped_disk);
-        ped_device_destroy (dev);
+    lb = fdisk_get_label (cxt, NULL);
+    if (!lb) {
+        g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
+                     "Failed to read partition table on device '%s'", disk);
         bd_utils_report_finished (progress_id, (*error)->message);
+        close_context (cxt);
         return FALSE;
     }
 
-    /* our flags are 1s shifted to the bit determined by parted's flags
-     * (i.e. 1 << 3 instead of 3, etc.) */
-    if (flag < BD_PART_FLAG_BASIC_LAST) {
-        ped_flag = (PedPartitionFlag) log2 ((double) flag);
-        status = ped_partition_set_flag (ped_part, ped_flag, (int) state);
-        if (status == 0) {
-            set_parted_error (error, BD_PART_ERROR_FAIL);
-            g_prefix_error (error, "Failed to set flag on partition '%d' on device '%s'", part_num, disk);
-            ped_disk_destroy (ped_disk);
-            ped_device_destroy (dev);
+    label_name = fdisk_label_get_name (lb);
+
+    /* boot flag is a real flag, not an ID/GUID */
+    if (flag == BD_PART_FLAG_BOOT) {
+        if (!set_boot_flag (cxt, part_num, state, error)) {
+            close_context (cxt);
+            g_prefix_error (error, "Failed to set boot flag on partition '%s': ", part);
             bd_utils_report_finished (progress_id, (*error)->message);
             return FALSE;
         }
-
-        ret = disk_commit (ped_disk, disk, error);
+    /* hidden and lba flags are in fact special partition IDs */
+    } else if (flag == BD_PART_FLAG_HIDDEN || flag == BD_PART_FLAG_LBA) {
+        part_id = get_lba_hidden_id (part, flag == BD_PART_FLAG_HIDDEN, flag == BD_PART_FLAG_LBA, state, error);
+        if (part_id) {
+            if (!set_part_type (cxt, part_num, part_id, BD_PART_TABLE_MSDOS, error)) {
+                bd_utils_report_finished (progress_id, (*error)->message);
+                g_free (part_id);
+                close_context (cxt);
+                return FALSE;
+            }
+        } else {
+            if (*error == NULL) {
+                /* NULL as part ID, but no error (e.g. unsupported FS) -> do nothing */
+                bd_utils_report_finished (progress_id, "Completed");
+                close_context (cxt);
+                return TRUE;
+            } else {
+                g_prefix_error (error, "Failed to calculate partition ID to set: ");
+                bd_utils_report_finished (progress_id, (*error)->message);
+                close_context (cxt);
+                return FALSE;
+            }
+        }
+    /* parition types/GUIDs (GPT) or IDs (MSDOS) */
     } else {
-        if (g_strcmp0 (ped_disk->type->name, "gpt") == 0)
-            ret = set_gpt_flag (disk, part_num, flag, state, error);
-        else
+        flag_info = part_flags[log2i (flag) - 1];
+        if (g_strcmp0 (label_name, table_type_str_fdisk[BD_PART_TABLE_MSDOS]) == 0 && flag_info.id) {
+            if (!set_part_type (cxt, part_num, state ? flag_info.id : DEFAULT_PART_ID, BD_PART_TABLE_MSDOS, error)) {
+                bd_utils_report_finished (progress_id, (*error)->message);
+                close_context (cxt);
+                return FALSE;
+            }
+        } else if (g_strcmp0 (label_name, table_type_str_fdisk[BD_PART_TABLE_GPT]) == 0 && flag_info.guid) {
+            if (!set_part_type (cxt, part_num, state ? flag_info.id : DEFAULT_PART_GUID, BD_PART_TABLE_GPT, error)) {
+                bd_utils_report_finished (progress_id, (*error)->message);
+                close_context (cxt);
+                return FALSE;
+            }
+        } else {
             g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_INVAL,
-                         "Cannot set a GPT flag on a non-GPT disk");
+                         "Setting flag '%s' is not supported on '%s' partition table", flag_info.name, label_name);
+            bd_utils_report_finished (progress_id, (*error)->message);
+            close_context (cxt);
+            return FALSE;
+        }
     }
 
-    ped_disk_destroy (ped_disk);
-    ped_device_destroy (dev);
+    if (!write_label (cxt, disk, error)) {
+        bd_utils_report_finished (progress_id, (*error)->message);
+        close_context (cxt);
+        return FALSE;
+    }
 
+    close_context (cxt);
     bd_utils_report_finished (progress_id, "Completed");
-
-    return ret;
+    return TRUE;
 }
 
 static gboolean set_pmbr_boot_flag (struct fdisk_context *cxt, gboolean state, GError **error) {
@@ -2217,7 +2518,7 @@ const gchar* bd_part_get_part_table_type_str (BDPartTableType type, GError **err
  */
 const gchar* bd_part_get_flag_str (BDPartFlag flag, GError **error) {
     if (flag < BD_PART_FLAG_BASIC_LAST)
-        return ped_partition_flag_get_name ((PedPartitionFlag) log2 ((double) flag));
+        return part_flags[log2i (flag) - 1].name;
     if (flag == BD_PART_FLAG_GPT_SYSTEM_PART)
         return "system partition";
     if (flag == BD_PART_FLAG_GPT_READ_ONLY)
diff --git a/tests/part_test.py b/tests/part_test.py
index f160097..71ca93f 100644
--- a/tests/part_test.py
+++ b/tests/part_test.py
@@ -1,6 +1,6 @@
 import unittest
 import os
-from utils import create_sparse_tempfile, create_lio_device, delete_lio_device, TestTags, tag_test
+from utils import create_sparse_tempfile, create_lio_device, delete_lio_device, TestTags, tag_test, run_command
 import overrides_hack
 
 from gi.repository import BlockDev, GLib
@@ -1117,12 +1117,7 @@ class PartSetFlagCase(PartTestCase):
         self.assertTrue(ps.flags & BlockDev.PartFlag.BOOT)
         self.assertTrue(ps.flags & BlockDev.PartFlag.LVM)
 
-        # SWAP label not supported on the MSDOS table
-        with self.assertRaises(GLib.GError):
-            BlockDev.part_set_part_flag (self.loop_dev, ps.path, BlockDev.PartFlag.SWAP, True)
-        with self.assertRaises(GLib.GError):
-            BlockDev.part_set_part_flag (self.loop_dev, ps.path, BlockDev.PartFlag.SWAP, False)
-        # so isn't GPT_HIDDEN
+        # GPT_HIDDEN is not supported on the MSDOS table
         with self.assertRaises(GLib.GError):
             BlockDev.part_set_part_flag (self.loop_dev, ps.path, BlockDev.PartFlag.GPT_HIDDEN, True)
         with self.assertRaises(GLib.GError):
@@ -1175,6 +1170,73 @@ class PartSetFlagCase(PartTestCase):
         self.assertTrue(ps.flags & BlockDev.PartFlag.GPT_HIDDEN)
         self.assertTrue(ps.flags & BlockDev.PartFlag.GPT_NO_AUTOMOUNT)
 
+    def test_set_part_flag_hidden(self):
+        """Verify that it is possible to set the hidden partition flag"""
+
+        # hidden (and lba) flag is special, because the way it is set depends on
+        # the filesystem (different part ID for FAT12/16/32 and NTFS) so better
+        # start with a clean test environment
+
+        # we first need a partition table
+        succ = BlockDev.part_create_table (self.loop_dev, BlockDev.PartTableType.MSDOS, True)
+        self.assertTrue(succ)
+
+        # for now, let's just create a typical primary partition starting at the
+        # sector 2048, 80 MiB big with optimal alignment
+        ps = BlockDev.part_create_part (self.loop_dev, BlockDev.PartTypeReq.NORMAL, 2048*512, 80 * 1024**2, BlockDev.PartAlign.OPTIMAL)
+        self.assertTrue(ps)
+        self.assertEqual(ps.flags, 0)  # no flags (combination of bit flags)
+
+        # no filesystem -> hidden shouldn't be set
+        succ = BlockDev.part_set_part_flag (self.loop_dev, ps.path, BlockDev.PartFlag.HIDDEN, True)
+        self.assertTrue(succ)
+        ps = BlockDev.part_get_part_spec (self.loop_dev, ps.path)
+        self.assertEqual(ps.flags, 0)
+
+        # now format the partition to FAT12
+        ret, out, err = run_command("mkfs.fat -F 12 %s" % ps.path)
+        if ret != 0:
+            self.fail("Failed to format partition to fat12 for flag test case:\n%s\n%s" % (out, err))
+        self.addCleanup(run_command, "wipefs -a %s" % ps.path)
+
+        # hidden is supported on FAT12
+        succ = BlockDev.part_set_part_flag (self.loop_dev, ps.path, BlockDev.PartFlag.HIDDEN, True)
+        self.assertTrue(succ)
+        ps = BlockDev.part_get_part_spec (self.loop_dev, ps.path)
+        self.assertTrue(ps.flags & BlockDev.PartFlag.HIDDEN)
+
+        # remove the flag
+        succ = BlockDev.part_set_part_flag (self.loop_dev, ps.path, BlockDev.PartFlag.HIDDEN, False)
+        self.assertTrue(succ)
+        ps = BlockDev.part_get_part_spec (self.loop_dev, ps.path)
+        self.assertFalse(ps.flags & BlockDev.PartFlag.HIDDEN)
+
+        # now format the partition to FAT32
+        ret, out, err = run_command("mkfs.fat -F 32 %s" % ps.path)
+        if ret != 0:
+            self.fail("Failed to format partition to fat32 for flag test case:\n%s\n%s" % (out, err))
+
+        # hidden is supported on FAT32
+        succ = BlockDev.part_set_part_flag (self.loop_dev, ps.path, BlockDev.PartFlag.HIDDEN, True)
+        self.assertTrue(succ)
+        ps = BlockDev.part_get_part_spec (self.loop_dev, ps.path)
+        self.assertTrue(ps.flags & BlockDev.PartFlag.HIDDEN)
+
+        # lba is also supported on FAT32
+        succ = BlockDev.part_set_part_flag (self.loop_dev, ps.path, BlockDev.PartFlag.LBA, True)
+        self.assertTrue(succ)
+        ps = BlockDev.part_get_part_spec (self.loop_dev, ps.path)
+        self.assertTrue(ps.flags & BlockDev.PartFlag.LBA)
+        self.assertTrue(ps.flags & BlockDev.PartFlag.HIDDEN)
+
+        # unset the lba flag
+        succ = BlockDev.part_set_part_flag (self.loop_dev, ps.path, BlockDev.PartFlag.LBA, False)
+        self.assertTrue(succ)
+        ps = BlockDev.part_get_part_spec (self.loop_dev, ps.path)
+        self.assertFalse(ps.flags & BlockDev.PartFlag.LBA)
+        self.assertTrue(ps.flags & BlockDev.PartFlag.HIDDEN)
+
+
 class PartSetDiskFlagCase(PartTestCase):
     def test_set_disk_flag(self):
         """Verify that it is possible to set disk flag(s)"""
@@ -1427,7 +1489,7 @@ class PartSetGptFlagsCase(PartTestCase):
         self.assertEqual(ps.type_guid, esp_guid)
 
         # set LEGACY_BOOT flag and test it
-        succ = BlockDev.part_set_part_flags (self.loop_dev, ps.path, BlockDev.PartFlag.LEGACY_BOOT)
+        succ = BlockDev.part_set_part_flag (self.loop_dev, ps.path, BlockDev.PartFlag.LEGACY_BOOT, True)
         self.assertTrue(succ)
         ps = BlockDev.part_get_part_spec (self.loop_dev, ps.path)
         self.assertTrue(ps.flags & BlockDev.PartFlag.LEGACY_BOOT)
-- 
2.33.1

