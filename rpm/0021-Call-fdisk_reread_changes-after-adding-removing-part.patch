From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Vojtech Trefny <vtrefny@redhat.com>
Date: Thu, 18 Jul 2019 13:01:35 +0200
Subject: [PATCH] Call 'fdisk_reread_changes' after adding/removing partitions

Also save partition table state before adding/removing partitions
so fdisk can run the BLKPG_* ioctls only for changed partitions.
---
 src/plugins/part.c | 108 +++++++++++++++++++++++++++++++++++----------
 1 file changed, 84 insertions(+), 24 deletions(-)

diff --git a/src/plugins/part.c b/src/plugins/part.c
index 70e2f89..e8897aa 100644
--- a/src/plugins/part.c
+++ b/src/plugins/part.c
@@ -279,16 +279,52 @@ static void close_context (struct fdisk_context *cxt) {
     fdisk_unref_context (cxt);
 }
 
-static gboolean write_label (struct fdisk_context *cxt, const gchar *disk, GError **error) {
+static gboolean write_label (struct fdisk_context *cxt, struct fdisk_table *orig, const gchar *disk, GError **error) {
     gint ret = 0;
-    ret = fdisk_write_disklabel (cxt);
+    gint dev_fd = 0;
+    guint num_tries = 1;
+
+    /* XXX: try to grab a lock for the device so that udev doesn't step in
+       between the two operations we need to perform (see below) with its
+       BLKRRPART ioctl() call which makes the device busy */
+    dev_fd = open (disk, O_RDONLY|O_CLOEXEC);
+    if (dev_fd >= 0) {
+        ret = flock (dev_fd, LOCK_SH|LOCK_NB);
+        while ((ret != 0) && (num_tries <= 5)) {
+            g_usleep (100 * 1000); /* microseconds */
+            ret = flock (dev_fd, LOCK_SH|LOCK_NB);
+            num_tries++;
+        }
+    }
+
+    /* Just continue even in case we don't get the lock, there's still a
+       chance things will just work. If not, an error will be reported
+       anyway with no harm. */
 
+    ret = fdisk_write_disklabel (cxt);
     if (ret != 0) {
         g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
                      "Failed to write the new disklabel to disk '%s': %s", disk, strerror_l (-ret, c_locale));
+        if (dev_fd >= 0)
+            close (dev_fd);
         return FALSE;
     }
 
+    /* We have original table layout -- reread changed partitions */
+    if (orig) {
+        ret = fdisk_reread_changes (cxt, orig);
+        if (ret != 0) {
+            g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
+                         "Failed to inform kernel about changes on the '%s' device: %s", disk, strerror_l (-ret, c_locale));
+            if (dev_fd >= 0)
+                close (dev_fd);
+            return FALSE;
+        }
+    }
+
+    if (dev_fd >= 0)
+        close (dev_fd);
+
     return TRUE;
 }
 
@@ -481,7 +517,7 @@ gboolean bd_part_create_table (const gchar *disk, BDPartTableType type, gboolean
         return FALSE;
     }
 
-    if (!write_label (cxt, disk, error)) {
+    if (!write_label (cxt, NULL, disk, error)) {
         bd_utils_report_finished (progress_id, (*error)->message);
         close_context (cxt);
         return FALSE;
@@ -1318,10 +1354,21 @@ BDPartSpec* bd_part_create_part (const gchar *disk, BDPartTypeReq type, guint64
         return NULL;
     }
 
+    status = fdisk_get_partitions (cxt, &table);
+    if (status != 0) {
+        g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
+                     "Failed to get existing partitions on the device: %s", strerror_l (-status, c_locale));
+        fdisk_unref_partition (npa);
+        close_context (cxt);
+        bd_utils_report_finished (progress_id, (*error)->message);
+        return NULL;
+   }
+
     npa = fdisk_new_partition ();
     if (!npa) {
         g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
                          "Failed to create new partition object");
+        fdisk_unref_table (table);
         close_context (cxt);
         bd_utils_report_finished (progress_id, (*error)->message);
         return NULL;
@@ -1340,6 +1387,7 @@ BDPartSpec* bd_part_create_part (const gchar *disk, BDPartTypeReq type, guint64
     if (status != 0) {
         g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
                      "Failed to setup alignment");
+        fdisk_unref_table (table);
         close_context (cxt);
         bd_utils_report_finished (progress_id, (*error)->message);
         return NULL;
@@ -1351,6 +1399,7 @@ BDPartSpec* bd_part_create_part (const gchar *disk, BDPartTypeReq type, guint64
     if (status != 0) {
         g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
                      "Failed to setup alignment");
+        fdisk_unref_table (table);
         close_context (cxt);
         bd_utils_report_finished (progress_id, (*error)->message);
         return NULL;
@@ -1390,6 +1439,7 @@ BDPartSpec* bd_part_create_part (const gchar *disk, BDPartTypeReq type, guint64
         if (fdisk_partition_set_size (npa, size) != 0) {
             g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
                          "Failed to set partition size");
+            fdisk_unref_table (table);
             fdisk_unref_partition (npa);
             close_context (cxt);
             bd_utils_report_finished (progress_id, (*error)->message);
@@ -1408,6 +1458,7 @@ BDPartSpec* bd_part_create_part (const gchar *disk, BDPartTypeReq type, guint64
     if (on_gpt && type != BD_PART_TYPE_REQ_NORMAL) {
         g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
                      "Only normal partitions are supported on GPT.");
+        fdisk_unref_table (table);
         fdisk_unref_partition (npa);
         close_context (cxt);
         bd_utils_report_finished (progress_id, (*error)->message);
@@ -1416,18 +1467,8 @@ BDPartSpec* bd_part_create_part (const gchar *disk, BDPartTypeReq type, guint64
 
     /* on DOS we may have to decide if requested */
     if (type == BD_PART_TYPE_REQ_NEXT) {
-        status = fdisk_get_partitions (cxt, &table);
-        if (status != 0) {
-            g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
-                         "Failed to get existing partitions on the device: %s", strerror_l (-status, c_locale));
-            fdisk_unref_partition (npa);
-            close_context (cxt);
-            bd_utils_report_finished (progress_id, (*error)->message);
-            return NULL;
-       }
-
-       iter = fdisk_new_iter (FDISK_ITER_FORWARD);
-       while (fdisk_table_next_partition (table, iter, &pa) == 0) {
+        iter = fdisk_new_iter (FDISK_ITER_FORWARD);
+        while (fdisk_table_next_partition (table, iter, &pa) == 0) {
             if (fdisk_partition_is_freespace (pa))
                 continue;
             if (!epa && fdisk_partition_is_container (pa))
@@ -1545,7 +1586,6 @@ BDPartSpec* bd_part_create_part (const gchar *disk, BDPartTypeReq type, guint64
             type = BD_PART_TYPE_NORMAL;
 
         fdisk_free_iter (iter);
-        fdisk_unref_table (table);
     }
 
     if (type == BD_PART_TYPE_REQ_EXTENDED) {
@@ -1554,6 +1594,7 @@ BDPartSpec* bd_part_create_part (const gchar *disk, BDPartTypeReq type, guint64
         if (fdisk_partition_set_type (npa, ptype) != 0) {
             g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
                          "Failed to set partition type");
+            fdisk_unref_table (table);
             fdisk_unref_partition (npa);
             close_context (cxt);
             bd_utils_report_finished (progress_id, (*error)->message);
@@ -1566,6 +1607,7 @@ BDPartSpec* bd_part_create_part (const gchar *disk, BDPartTypeReq type, guint64
     if (fdisk_partition_set_start (npa, start) != 0) {
         g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
                      "Failed to set partition start");
+        fdisk_unref_table (table);
         fdisk_unref_partition (npa);
         close_context (cxt);
         bd_utils_report_finished (progress_id, (*error)->message);
@@ -1583,6 +1625,7 @@ BDPartSpec* bd_part_create_part (const gchar *disk, BDPartTypeReq type, guint64
         if (status != 0) {
             g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
                          "Failed to get new partition number");
+            fdisk_unref_table (table);
             fdisk_unref_partition (npa);
             close_context (cxt);
             bd_utils_report_finished (progress_id, (*error)->message);
@@ -1594,6 +1637,7 @@ BDPartSpec* bd_part_create_part (const gchar *disk, BDPartTypeReq type, guint64
     if (status != 0) {
         g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
                      "Failed to set new partition number");
+        fdisk_unref_table (table);
         fdisk_unref_partition (npa);
         close_context (cxt);
         bd_utils_report_finished (progress_id, (*error)->message);
@@ -1604,14 +1648,16 @@ BDPartSpec* bd_part_create_part (const gchar *disk, BDPartTypeReq type, guint64
     if (status != 0) {
         g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
                      "Failed to add new partition to the table: %s", strerror_l (-status, c_locale));
+        fdisk_unref_table (table);
         fdisk_unref_partition (npa);
         close_context (cxt);
         bd_utils_report_finished (progress_id, (*error)->message);
         return NULL;
     }
 
-    if (!write_label (cxt, disk, error)) {
+    if (!write_label (cxt, table, disk, error)) {
         bd_utils_report_finished (progress_id, (*error)->message);
+        fdisk_unref_table (table);
         fdisk_unref_partition (npa);
         close_context (cxt);
         return NULL;
@@ -1625,6 +1671,7 @@ BDPartSpec* bd_part_create_part (const gchar *disk, BDPartTypeReq type, guint64
     }
 
     /* close the context now, we no longer need it */
+    fdisk_unref_table (table);
     fdisk_unref_partition (npa);
     close_context (cxt);
 
@@ -1652,6 +1699,7 @@ BDPartSpec* bd_part_create_part (const gchar *disk, BDPartTypeReq type, guint64
 gboolean bd_part_delete_part (const gchar *disk, const gchar *part, GError **error) {
     gint part_num = 0;
     struct fdisk_context *cxt = NULL;
+    struct fdisk_table *table = NULL;
     gint ret = 0;
     guint64 progress_id = 0;
     gchar *msg = NULL;
@@ -1675,21 +1723,33 @@ gboolean bd_part_delete_part (const gchar *disk, const gchar *part, GError **err
         return FALSE;
     }
 
+    ret = fdisk_get_partitions (cxt, &table);
+    if (ret != 0) {
+        g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
+                     "Failed to get existing partitions on the device: %s", strerror_l (-ret, c_locale));
+        close_context (cxt);
+        bd_utils_report_finished (progress_id, (*error)->message);
+        return FALSE;
+   }
+
     ret = fdisk_delete_partition (cxt, (size_t) part_num);
     if (ret != 0) {
         g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
                      "Failed to delete partition '%d' on device '%s': %s", part_num+1, disk, strerror_l (-ret, c_locale));
+        fdisk_unref_table (table);
         close_context (cxt);
         bd_utils_report_finished (progress_id, (*error)->message);
         return FALSE;
     }
 
-    if (!write_label (cxt, disk, error)) {
+    if (!write_label (cxt, table, disk, error)) {
         bd_utils_report_finished (progress_id, (*error)->message);
+        fdisk_unref_table (table);
         close_context (cxt);
         return FALSE;
     }
 
+    fdisk_unref_table (table);
     close_context (cxt);
 
     bd_utils_report_finished (progress_id, "Completed");
@@ -2241,7 +2301,7 @@ gboolean bd_part_set_part_flag (const gchar *disk, const gchar *part, BDPartFlag
             return FALSE;
         }
 
-        if (!write_label (cxt, disk, error)) {
+        if (!write_label (cxt, NULL, disk, error)) {
             bd_utils_report_finished (progress_id, (*error)->message);
             close_context (cxt);
             return FALSE;
@@ -2318,7 +2378,7 @@ gboolean bd_part_set_part_flag (const gchar *disk, const gchar *part, BDPartFlag
         }
     }
 
-    if (!write_label (cxt, disk, error)) {
+    if (!write_label (cxt, NULL, disk, error)) {
         bd_utils_report_finished (progress_id, (*error)->message);
         close_context (cxt);
         return FALSE;
@@ -2588,7 +2648,7 @@ gboolean bd_part_set_part_flags (const gchar *disk, const gchar *part, guint64 f
         }
     }
 
-    if (!write_label (cxt, disk, error)) {
+    if (!write_label (cxt, NULL, disk, error)) {
         bd_utils_report_finished (progress_id, (*error)->message);
         close_context (cxt);
         return FALSE;
@@ -2691,7 +2751,7 @@ gboolean bd_part_set_part_name (const gchar *disk, const gchar *part, const gcha
 
     fdisk_unref_partition (pa);
 
-    if (!write_label (cxt, disk, error)) {
+    if (!write_label (cxt, NULL, disk, error)) {
         bd_utils_report_finished (progress_id, (*error)->message);
         close_context (cxt);
         return FALSE;
@@ -2743,7 +2803,7 @@ gboolean bd_part_set_part_type (const gchar *disk, const gchar *part, const gcha
         return FALSE;
     }
 
-    if (!write_label (cxt, disk, error)) {
+    if (!write_label (cxt, NULL, disk, error)) {
         bd_utils_report_finished (progress_id, (*error)->message);
         close_context (cxt);
         return FALSE;
@@ -2797,7 +2857,7 @@ gboolean bd_part_set_part_id (const gchar *disk, const gchar *part, const gchar
         return FALSE;
     }
 
-    if (!write_label (cxt, disk, error)) {
+    if (!write_label (cxt, NULL, disk, error)) {
         bd_utils_report_finished (progress_id, (*error)->message);
         close_context (cxt);
         return FALSE;
-- 
2.33.1

