From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Vojtech Trefny <vtrefny@redhat.com>
Date: Fri, 25 Sep 2020 12:18:22 +0200
Subject: [PATCH] part: When resizing allow growing up to 4 MiB above max size

In this case we should simply round the size down to the max size
to make the resize process more user friendly. This is also how
the libparted based implementation behaved.
---
 src/plugins/part.c | 45 +++++++++++++++++++++++++++++++--------------
 tests/part_test.py | 20 ++++++++++++++++++++
 2 files changed, 51 insertions(+), 14 deletions(-)

diff --git a/src/plugins/part.c b/src/plugins/part.c
index db9da3c..b7e92bd 100644
--- a/src/plugins/part.c
+++ b/src/plugins/part.c
@@ -1624,6 +1624,7 @@ gboolean bd_part_resize_part (const gchar *disk, const gchar *part, guint64 size
     guint64 sector_size = 0;
     guint64 grain_size = 0;
     guint64 progress_id = 0;
+    guint64 max_size = 0;
     gchar *msg = NULL;
 
     msg = g_strdup_printf ("Started resizing partition '%s'", part);
@@ -1677,7 +1678,7 @@ gboolean bd_part_resize_part (const gchar *disk, const gchar *part, guint64 size
     }
 
     if (fdisk_partition_has_size (pa))
-        old_size = (guint64) fdisk_partition_get_size (pa) * fdisk_get_sector_size (cxt);
+        old_size = (guint64) fdisk_partition_get_size (pa);
     else {
         g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
                      "Failed to get size for partition %d on device '%s'", part_num, disk);
@@ -1697,19 +1698,18 @@ gboolean bd_part_resize_part (const gchar *disk, const gchar *part, guint64 size
         grain_size = (guint64) fdisk_get_minimal_iosize (cxt);
     /* else OPTIMAL or unknown -> nothing to do */
 
-    if (size == 0) {
-        /* no size specified, set the end to default (maximum) */
-        if (!get_max_part_size (table, part_num, &size, error)) {
-            g_prefix_error (error, "Failed to get maximal size for '%s': ", part);
-            fdisk_unref_table (table);
-            fdisk_unref_partition (pa);
-            close_context (cxt);
-            bd_utils_report_finished (progress_id, (*error)->message);
-            return FALSE;
-        }
+    if (!get_max_part_size (table, part_num, &max_size, error)) {
+        g_prefix_error (error, "Failed to get maximal size for '%s': ", part);
+        fdisk_unref_table (table);
+        fdisk_unref_partition (pa);
+        close_context (cxt);
+        bd_utils_report_finished (progress_id, (*error)->message);
+        return FALSE;
+    }
 
-        if (size == 0) {
-            bd_utils_log_format (LOG_INFO, "Not resizing, partition '%s' is already at its maximum size.", part);
+    if (size == 0) {
+        if (max_size == old_size) {
+            g_info ("Not resizing, partition '%s' is already at its maximum size.", part);
             fdisk_unref_table (table);
             fdisk_unref_partition (pa);
             close_context (cxt);
@@ -1717,7 +1717,7 @@ gboolean bd_part_resize_part (const gchar *disk, const gchar *part, guint64 size
             return TRUE;
         }
 
-        if (fdisk_partition_set_size (pa, size) != 0) {
+        if (fdisk_partition_set_size (pa, max_size) != 0) {
             g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
                          "Failed to set size for partition %d on device '%s'", part_num, disk);
             fdisk_unref_table (table);
@@ -1741,6 +1741,23 @@ gboolean bd_part_resize_part (const gchar *disk, const gchar *part, guint64 size
             return TRUE;
         }
 
+        if (size > old_size && size > max_size) {
+            if (size - max_size <= 4 MiB / sector_size) {
+                                  g_info ("Requested size %"G_GUINT64_FORMAT" is bigger than max size for partition '%s', adjusting to %"G_GUINT64_FORMAT".",
+                                     size * sector_size, part, max_size * sector_size);
+                size = max_size;
+            } else {
+                g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
+                             "Requested size %"G_GUINT64_FORMAT" is bigger than max size (%"G_GUINT64_FORMAT") for partition '%s'",
+                             size * sector_size, max_size * sector_size, part);
+                fdisk_unref_table (table);
+                fdisk_unref_partition (pa);
+                close_context (cxt);
+                bd_utils_report_finished (progress_id, (*error)->message);
+                return FALSE;
+            }
+        }
+
         if (fdisk_partition_set_size (pa, size) != 0) {
             g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
                          "Failed to set partition size");
diff --git a/tests/part_test.py b/tests/part_test.py
index 5ba39f8..e40ed9f 100644
--- a/tests/part_test.py
+++ b/tests/part_test.py
@@ -1,5 +1,6 @@
 import unittest
 import os
+import six
 from utils import create_sparse_tempfile, create_lio_device, delete_lio_device, TestTags, tag_test, run_command
 import overrides_hack
 
@@ -1069,6 +1070,25 @@ class PartCreateResizePartCase(PartTestCase):
         self.assertEqual(initial_start, ps.start)
         self.assertGreaterEqual(ps.size, initial_size) # at least the requested size
 
+        # resize back to 20 MB (not MiB) with no alignment
+        new_size = 20 * 1000**2
+        succ = BlockDev.part_resize_part (self.loop_dev, ps.path, new_size, BlockDev.PartAlign.NONE)
+        self.assertTrue(succ)
+        ps = BlockDev.part_get_part_spec(self.loop_dev, ps.path)
+        self.assertEqual(initial_start, ps.start)  # offset must not be moved
+        self.assertGreaterEqual(ps.size, new_size)  # at least the requested size
+        self.assertLess(ps.size, new_size + 4 * 1024)  # but also not too big (assuming max. 4 KiB blocks)
+
+        # resize should allow up to 4 MiB over max size
+        with six.assertRaisesRegex(self, GLib.GError, "is bigger than max size"):
+            BlockDev.part_resize_part (self.loop_dev, ps.path, initial_size + 4*1024**2 + 1, BlockDev.PartAlign.NONE)
+
+        succ = BlockDev.part_resize_part (self.loop_dev, ps.path, initial_size + 4*1024**2, BlockDev.PartAlign.NONE)
+        self.assertTrue(succ)
+        ps = BlockDev.part_get_part_spec(self.loop_dev, ps.path)
+        self.assertEqual(initial_start, ps.start)
+        self.assertGreaterEqual(ps.size, initial_size) # at least the requested size
+
 class PartCreateDeletePartCase(PartTestCase):
     @tag_test(TestTags.CORE)
     def test_create_delete_part_simple(self):
-- 
2.33.1

