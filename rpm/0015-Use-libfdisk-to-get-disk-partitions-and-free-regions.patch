From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Vojtech Trefny <vtrefny@redhat.com>
Date: Fri, 21 Jun 2019 12:56:49 +0200
Subject: [PATCH] Use libfdisk to get disk partitions and free regions

Unfortunately fdisk ignores all free regions smaller than grain
size (usually 1 MiB) so this slightly changes behaviour of the
functions.
---
 src/plugins/part.c | 97 +++++++++++++++++++++++++++++++---------------
 tests/part_test.py | 58 ++++++++++++---------------
 2 files changed, 89 insertions(+), 66 deletions(-)

diff --git a/src/plugins/part.c b/src/plugins/part.c
index 4d52590..08068d9 100644
--- a/src/plugins/part.c
+++ b/src/plugins/part.c
@@ -902,51 +902,85 @@ BDPartDiskSpec* bd_part_get_disk_spec (const gchar *disk, GError **error) {
     return ret;
 }
 
-static BDPartSpec** get_disk_parts (const gchar *disk, guint64 incl, guint64 excl, gboolean incl_normal, GError **error) {
-    PedDevice *dev = NULL;
-    PedDisk *ped_disk = NULL;
-    PedPartition *ped_part = NULL;
-    guint num_parts = 0;
+static BDPartSpec** get_disk_parts (const gchar *disk, gboolean parts, gboolean freespaces, GError **error) {
+    struct fdisk_context *cxt = NULL;
+    struct fdisk_table *table = NULL;
+    struct fdisk_partition *pa = NULL;
+    struct fdisk_iter *itr = NULL;
     BDPartSpec **ret = NULL;
+    BDPartSpec *spec = NULL;
     guint i = 0;
+    gint status = 0;
+    size_t num_parts = 0;
 
-    dev = ped_device_get (disk);
-    if (!dev) {
-        set_parted_error (error, BD_PART_ERROR_INVAL);
-        g_prefix_error (error, "Device '%s' invalid or not existing", disk);
+    cxt = get_device_context (disk, error);
+    if (!cxt) {
+        /* error is already populated */
         return NULL;
     }
 
-    ped_disk = ped_disk_new (dev);
-    if (!ped_disk) {
-        set_parted_error (error, BD_PART_ERROR_FAIL);
-        g_prefix_error (error, "Failed to read partition table on device '%s'", disk);
-        ped_device_destroy (dev);
+    table = fdisk_new_table ();
+    if (!table) {
+        g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
+                     "Failed to create a new table");
+        close_context (cxt);
         return NULL;
     }
 
-    /* count the partitions we care about */
-    ped_part = ped_disk_next_partition (ped_disk, NULL);
-    while (ped_part) {
-        if (((ped_part->type & incl) && !(ped_part->type & excl)) ||
-            ((ped_part->type == 0) && incl_normal))
-            num_parts++;
-        ped_part = ped_disk_next_partition (ped_disk, ped_part);
+    itr = fdisk_new_iter (FDISK_ITER_FORWARD);
+    if (!itr) {
+        g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
+                     "Failed to create a new iterator");
+        close_context (cxt);
+        return NULL;
+    }
+
+    if (parts) {
+        status = fdisk_get_partitions (cxt, &table);
+        if (status != 0) {
+            g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
+                         "Failed to get partitions: %s", strerror_l (-status, c_locale));
+            fdisk_free_iter (itr);
+            fdisk_unref_table (table);
+            close_context (cxt);
+            return NULL;
+        }
+    }
+
+    if (freespaces) {
+        status = fdisk_get_freespaces (cxt, &table);
+        if (status != 0) {
+            g_set_error (error, BD_PART_ERROR, BD_PART_ERROR_FAIL,
+                         "Failed to get free spaces: %s", strerror_l (-status, c_locale));
+            fdisk_free_iter (itr);
+            fdisk_unref_table (table);
+            close_context (cxt);
+            return NULL;
+        }
     }
 
     ret = g_new0 (BDPartSpec*, num_parts + 1);
     i = 0;
-    ped_part = ped_disk_next_partition (ped_disk, NULL);
-    while (ped_part) {
-        if (((ped_part->type & incl) && !(ped_part->type & excl)) ||
-            ((ped_part->type == 0) && incl_normal))
-            ret[i++] = get_part_spec (dev, ped_disk, ped_part, error);
-        ped_part = ped_disk_next_partition (ped_disk, ped_part);
+
+    while (fdisk_table_next_partition (table, itr, &pa) == 0) {
+        spec = get_part_spec_fdisk (cxt, pa, error);
+        if (!spec) {
+            for (BDPartSpec **part_list_p = ret; *part_list_p; part_list_p++)
+                bd_part_spec_free (*part_list_p);
+            g_free (ret);
+            fdisk_free_iter (itr);
+            fdisk_unref_table (table);
+            close_context (cxt);
+            return NULL;
+        }
+
+        ret[i++] = spec;
     }
     ret[i] = NULL;
 
-    ped_disk_destroy (ped_disk);
-    ped_device_destroy (dev);
+    fdisk_free_iter (itr);
+    fdisk_unref_table (table);
+    close_context (cxt);
 
     return ret;
 }
@@ -961,8 +995,7 @@ static BDPartSpec** get_disk_parts (const gchar *disk, guint64 incl, guint64 exc
  * Tech category: %BD_PART_TECH_MODE_QUERY_TABLE + the tech according to the partition table type
  */
 BDPartSpec** bd_part_get_disk_parts (const gchar *disk, GError **error) {
-    return get_disk_parts (disk, BD_PART_TYPE_NORMAL|BD_PART_TYPE_LOGICAL|BD_PART_TYPE_EXTENDED,
-                           BD_PART_TYPE_FREESPACE|BD_PART_TYPE_METADATA|BD_PART_TYPE_PROTECTED, TRUE, error);
+    return get_disk_parts (disk, TRUE, FALSE, error);
 }
 
 /**
@@ -975,7 +1008,7 @@ BDPartSpec** bd_part_get_disk_parts (const gchar *disk, GError **error) {
  * Tech category: %BD_PART_TECH_MODE_QUERY_TABLE + the tech according to the partition table type
  */
 BDPartSpec** bd_part_get_disk_free_regions (const gchar *disk, GError **error) {
-    return get_disk_parts (disk, BD_PART_TYPE_FREESPACE, 0, FALSE, error);
+    return get_disk_parts (disk, FALSE, TRUE, error);
 }
 
 /**
diff --git a/tests/part_test.py b/tests/part_test.py
index 28d1c90..13a3686 100644
--- a/tests/part_test.py
+++ b/tests/part_test.py
@@ -4,6 +4,7 @@ from utils import create_sparse_tempfile, create_lio_device, delete_lio_device,
 import overrides_hack
 
 from gi.repository import BlockDev, GLib
+from bytesize.bytesize import Size, ROUND_UP, B
 
 
 class PartTestCase(unittest.TestCase):
@@ -668,6 +669,13 @@ class PartGetDiskPartsCase(PartTestCase):
         with self.assertRaises(GLib.GError):
             BlockDev.part_get_disk_parts (self.loop_dev)
 
+
+def _round_up_mib(size):
+    # convert size to nearest MiB (up)
+    rounded = Size(size).round_to_nearest(Size(1024**2), rounding=ROUND_UP)
+    return rounded.get_bytes()
+
+
 class PartGetDiskFreeRegions(PartTestCase):
     @tag_test(TestTags.CORE)
     def test_get_disk_free_regions(self):
@@ -687,51 +695,36 @@ class PartGetDiskFreeRegions(PartTestCase):
         self.assertEqual(ps.size, 10 * 1024**2)
 
         fis = BlockDev.part_get_disk_free_regions (self.loop_dev)
-        self.assertEqual(len(fis), 2)  # 0-512, (512+10MiB)-EOD
+        self.assertEqual(len(fis), 1)
         fi = fis[0]
-        self.assertEqual(fi.start, 0)
-        self.assertEqual(fi.size, 512)
-        fi = fis[1]
-        self.assertEqual(fi.start, ps.start + ps.size)
-        self.assertGreater(fi.size, 89 * 1024**2)
+        self.assertEqual(fi.start, _round_up_mib(ps.start + ps.size))
+        self.assertGreaterEqual(fi.size, 89 * 1024**2)
 
         ps = BlockDev.part_create_part (self.loop_dev, BlockDev.PartTypeReq.NORMAL, ps.start + ps.size + 10 * 1024**2,
                                         10 * 1024**2, BlockDev.PartAlign.NONE)
         fis = BlockDev.part_get_disk_free_regions (self.loop_dev)
-        self.assertEqual(len(fis), 3)  # 0-512, first part, gap, second part, free
+        self.assertEqual(len(fis), 2)  # first part, gap, second part, free
         fi = fis[0]
-        self.assertEqual(fi.start, 0)
-        self.assertEqual(fi.size, 512)
+        self.assertEqual(fi.start, _round_up_mib(512 + 10 * 1024**2))
+        self.assertGreaterEqual(fi.size, 9 * 1024**2)
         fi = fis[1]
-        self.assertEqual(fi.start, 512 + 10 * 1024**2)
-        self.assertGreater(fi.size, 9 * 1024**2)
-        fi = fis[2]
-        self.assertEqual(fi.start, 512 + 30 * 1024**2)
-        self.assertGreater(fi.size, 69 * 1024**2)
+        self.assertEqual(fi.start, _round_up_mib(512 + 30 * 1024**2))
+        self.assertGreaterEqual(fi.size, 69 * 1024**2)
 
         ps = BlockDev.part_create_part (self.loop_dev, BlockDev.PartTypeReq.EXTENDED, ps.start + ps.size + 1,
                                         50 * 1024**2, BlockDev.PartAlign.NONE)
         ps = BlockDev.part_create_part (self.loop_dev, BlockDev.PartTypeReq.LOGICAL, ps.start + 1024**2,
                                         10 * 1024**2, BlockDev.PartAlign.NONE)
         fis = BlockDev.part_get_disk_free_regions (self.loop_dev)
-        self.assertEqual(len(fis), 6)  # 0-512[0], first part, gap[1], second part, gap[2], extended, gap[3], logical, free extended[4], free[5]
+        self.assertEqual(len(fis), 3)  # first part, gap[0], second part, extended, logical, free extended[1], free[2]
 
         fi = fis[0]
-        self.assertEqual(fi.start, 0)
-        self.assertEqual(fi.size, 512)
-        fi = fis[1]
-        self.assertEqual(fi.start, 512 + 10 * 1024**2)
+        self.assertEqual(fi.start, _round_up_mib(512 + 10 * 1024**2))
         self.assertGreater(fi.size, 9 * 1024**2)
+        fi = fis[1]
+        self.assertGreaterEqual(fi.start, _round_up_mib(ps.start + ps.size))
+        self.assertGreaterEqual(fi.size, 37 * 1024**2)
         fi = fis[2]
-        self.assertGreater(fi.start, 30 * 1024**2)
-        self.assertLessEqual(fi.size, 512)
-        fi = fis[3]
-        self.assertGreater(fi.start, 30 * 1024**2)
-        self.assertLessEqual(fi.size, 1024**2)
-        fi = fis[4]
-        self.assertGreaterEqual(fi.start, ps.start + ps.size)
-        self.assertGreaterEqual(fi.size, 38 * 1024**2)
-        fi = fis[5]
         self.assertGreaterEqual(fi.start, 80 * 1024**2)
         self.assertGreaterEqual(fi.size, 19 * 1024**2)
 
@@ -749,13 +742,10 @@ class PartGetDiskFreeRegions(PartTestCase):
         self.assertEqual(ps.size, 10 * 1024**2)
 
         fis = BlockDev.part_get_disk_free_regions (self.loop_dev)
-        self.assertEqual(len(fis), 2)  # 0-512, (512+10MiB)-EOD
+        self.assertEqual(len(fis), 1)
         fi = fis[0]
-        self.assertEqual(fi.start, 0)
-        self.assertEqual(fi.size, 512)
-        fi = fis[1]
-        self.assertEqual(fi.start, ps.start + ps.size)
-        self.assertGreater(fi.size, 89 * 1024**2)
+        self.assertEqual(fi.start, _round_up_mib(ps.start + ps.size))
+        self.assertGreaterEqual(fi.size, 89 * 1024**2)
 
 class PartGetBestFreeRegion(PartTestCase):
     def test_get_best_free_region(self):
-- 
2.33.1

